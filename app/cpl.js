#!/usr/bin/env node

var fs = require('fs')
  , jade = require('jade')
  , _ = require('underscore')
  , programm = require('commander')
  , jsp = require('uglify-js').parser
  , pro = require('uglify-js').uglify;


require('./underscore.escape.js');

programm
	.version('0.0.1')
	.option('-t, --templates [dir]', 'Root directory with templates')
	.option('-o, --output [file]', 'Output JS-file')
	.option('-c, --compress', 'Compress output with Uglify.js')
	.parse(process.argv);


if(!programm.templates) {
	console.log('You have to choose templates dir');
	process.exit(1);
}
if(!programm.output) {
	console.log('You have to choose output file');
	process.exit(1);
}

//----------------------------------------------------------------------
var dir = programm.templates;

var js = [];

var runtimeCode = fs.readFileSync(__dirname + '/jade.runtime.js', 'utf8');
var footCode = fs.readFileSync(__dirname + '/foot.js', 'utf8');

js.push('/*This file is generated by tplcpl :)*/');
js.push('');

js.push(';(function(exports){');//start IIFE

js.push('');
js.push('/*JADE runtime routines*/');
js.push(runtimeCode);
js.push('');
js.push('var escapeHTML = jade.escape;'); //added escape for underscore templates
js.push('/*Compiled templates*/');
js.push('var TPL = {};');

var files = glob(dir);
for(var i = 0; i < files.length; i++) {
	var src = fs.readFileSync(files[i], 'utf8');
//	console.log(src);
	var funcCode = compile(files[i], src);
	var name = files[i].replace(dir+'/', '');
	js.push('');
	js.push('/**');
	js.push(' * @template ' + name);
	js.push(' */');
	js.push('');
	js.push("TPL['" + name + "'] = " + funcCode + ';');
}

//-----------
js.push(footCode);

js.push('}(window));');


var JS = js.join('\n');
if(programm.compress) {
	JS = compress(JS);
}
fs.writeFileSync(programm.output, JS, 'utf8');
console.log('OK!');
	
//----------------------------------------------------------------------
function compress(js) {
	var ast = jsp.parse(js);
	ast = pro.ast_mangle(ast);
	//ast = pro.ast_lift_variables(ast);
	ast = pro.ast_squeeze(ast);
	var finalCode = pro.gen_code(ast);
	return finalCode;
}


function glob(root) {
	var files = [];
	
	_traverseSync (root);
	
	return files;
	
	function _traverseSync (dir) {
		var items = fs.readdirSync(dir);
		for(var i = 0 ; i < items.length; i++) {
			var item = items[i];
			if('.'===item.charAt(0)) { //dont process hidden files or dirs
				continue;
			}
			var path = dir + '/' + items[i];
			var stat = fs.statSync(path);
			if(stat.isDirectory()) {
				_traverseSync(path);
			} else {
				files.push(path);
			}
		}
	}
}


function compile(fileName, source) {
	var func,
		code,
		ext = fileName.split('.').pop();
	console.log('compiling:', fileName);
	switch (ext) {
		case 'jade':
			func = jade.compile(source, {
				filename : fileName,
				client : true,
				compileDebug : false
			});
		break;

		case 'us':
			func = _.template(source);
		break;
		
		default:
			console.log('SKIPPED unknown extension', ext);
		break;
	}
	code = func.toString().replace('function anonymous', 'function');
	return(code);
}
